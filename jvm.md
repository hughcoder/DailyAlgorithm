# JVM相关

### 1.简述 JVM 内存模型和内存区域？
jvm内存模型由以下五部分组成（即jvm运行时数据区域划分）

* 程序计数器 ：每一个线程都会分配一个程序计数器，指示执行哪条指令的。线程私有
（注：由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。）
* java虚拟机栈：描述的是java方法执行的内存模型，每一个方法在执行时都会创建一个栈帧（用于存储局部变量表，操作数栈等信息）线程私有
* 本地方法栈：为虚拟机使用到的Native方法服务 （注：在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。）
* java堆 ：所有线程共享的一块内存区域，存放对象实例，java堆事垃圾收集器管理的主要区域，从内存分配的角度来看，java堆可以分为：新生代和老年代；再细致一点可以分为 Eden空间、From Survivor空间、To Survivor空间
* 方法区：各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据


### 2.简述垃圾回收器的工作原理？（何为GC）
垃圾回收机制是由垃圾收集器Garbage Collection GC来实现的，GC是后台的守护进程。它的特别之处是它是一个低优先级进程，但是可以根据内存的使用情况动态的调整他的优先级。因此，它是在内存中低到一定限度时才会自动运行，从而实现对内存的回收。这就是垃圾回收的时间不确定的原因。

为何要这样设计：：因为GC也是进程，也要消耗CPU等资源，如果GC执行过于频繁会对java的程序的执行产生较大的影响（java解释器本来就不快），因此JVM的设计者们选着了不定期的gc。

因为垃圾回收gc只能回收通过new关键字申请的内存（在堆上），但是堆上的内存并不完全是通过new申请分配的。还有一些本地方法（一般是调用的C方法）。这部分“特殊的内存”如果不手动释放，就会导致内存泄露，gc是无法回收这部分内存的。 所以需要在finalize中用本地方法(native method)如free操作等，再使用gc方法。显示的GC方法是system.gc()

JVM 分别对新生代和旧生代采用不同的垃圾回收机制

### 3.如何判断对象的生死？垃圾回收算法？新生代，老生代？
* 如何判断对象的生死？
 
 1、引用计数算法：给对象添加一个引用计数器，每当一个地方引用它时，计数器就增加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。
 
 2、可达性分析算法：这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，但一个对象到GC Roots没有任何引用链相连时，则证明此对象时不可用的
 
 强软弱虚引用
 
 `具体判定生存还是死亡`
 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize方法，如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它（对象可通过在finalize中成功拯救自己 通过重新与引用链上的任何一个对象建立关联）

* 垃圾回收算法

方法一：标记 - 清除算法。首先标记，标记完再回收，效率低，产生大量不连续的内存碎片

方法二：复制算法。效率低，需要的空间大，优点，不会产生碎片。

方法三：标记 - 整理算法。速度较快，占用空间少

方法四：分代收集算法

一般是吧java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。
新生代：每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。
老年代：而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用 标记-整理 算法来进行回收


### 4.哪些情况下的对象会被垃圾回收机制处理掉？
回答引用计数法和可达性分析算法，那么，那些对象适用这两个算法，

* 虚拟机栈(栈桢中的本地变量表)中的引用的对象
* 方法区中的类静态属性引用的对象
* 方法区中的常量引用的对象
* 本地方法栈中JNI（Native方法）的引用的对象

### 5.垃圾回收机制与调用 System.gc() 的区别？

* 不要显式调用System.gc()
　
　此函数建议JVM进行主GC,虽然只是建议而非一定,但很多情况下它会触发主GC,从而增加主GC的频率,也即增加了间歇性停顿的次数。

### 6.强引用、软引用、弱引用、虚引用之间的区别？

### 7.强引用设置为 null，会不会被回收？
不会立即被回收，扫描到对象没有被引用则会标记对象，这时候仍然不会立即释放该对象内存，因为有些对象是可恢复的（在 finalize方法中恢复引用 ）。只有确定了对象无法恢复引用的时候才会清除对象内存。

### 8.简述 ClassLoader 类加载机制？

* 类加载器：通过一个类的全限定名来获取描述此类的二进制字节流
以便让应用程序自己决定如何去获取所需要的类，一个类对应一个类加载器，接下来可以直接讲解双亲委派模型

注： 对于任意一个类，都需要由`加载它的类加载器`和`这个类`本身一同确立在java虚拟机的唯一性。通俗一些：比较两个类是否“相等”,只有这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只有加载它们的类加载器不同，那么这两个类就必定不相等


### 9.对双亲委派模型的了解？

**类加载器分类**

* `启动类加载器`：启动类加载器最为特别，它是完全由C代码实现的，并且在Java中没有对象与之对应。因此任何加载在启动类加载器中的类是无法获得其ClassLoader实例的
* `扩展类加载器`：
* `应用程序类加载器`：

类加载之间的层次关系,称为： **类加载器的双亲委派模型**

<Image src ="./images/classloader.png"/>

双亲委派模型要求除了顶层的类加载器外，其余的类加载器都应当有自己的父类加载器。这里加载器之间的父子关系一般不会以继承的关系来实现，而是都用组合关系来复用父加载器的代码。

**工作过程**
如果一个类收到了类加载器的请求

1. 它首先不会去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求都应该最终传送到顶层的启动类加载器中

2. 只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，字加载器才会尝试自己去加载

**代码实现**

```
    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            //1.首先，检查请求的类是否被加载过
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                    //2。如果父类加载器抛出ClassNotFoundException，则说明父加载器无法完成加载请求
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    //3.在父类加载器无法加载的时候，在调用本身的findClass方法来进行类加载
                    long t1 = System.nanoTime();
                    c = findClass(name);
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }

```

**破坏双亲委派模型**

通过上述代码，我们可以明显看到修改loadClass方法或者调用自己的findClass都能打破双亲委派模型，但其实面试官更想获得的时引出热修复或插件化等原理，由于每一次发版本肯能影响用户的使用，或者出现重大故障，这里引申出代码热替换、模块热部署等概念，包括目前的RN的热部署都能讲一讲

Andoird动态化方案

`https://blog.csdn.net/smileiam/article/details/68927084`

1.Android热修复：
美团：https://tech.meituan.com/2016/09/14/android-robust.html
腾讯：

2.Android插件化：现在市面上比较少用了 重点放在热修复上吧

RN动态化方案
RN热更新

 



### 10.String a = "a"+"b"+"c" 在内存中创建几个对象？

`一个对象`
"a"+"b"+"c"在编译期已经常量折叠为"abc"
变量a获得是"abc"。

### 11.对 Dalvik、ART 虚拟机的了解？

* JVM 与 Dalvik 的区别
 
Dalvik 是一个更符合移动设备的用于执行 Java 代码的虚拟机

1.JVM 可以执行的文件是 .class 结尾的字节码文件，而 Dalvik 执行的是 dex 文件。

2.Dalvik 基于寄存器，而 JVM 基于栈，很明显，基于寄存器的 Dalvik 在速度方面优势会更明显。

* Dalivk 与 ART 虚拟机

从 Android L 开始，Android 开始启用了新设计的虚拟机 ART。与 Dalvik 不同，在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（Just In Time ，JIT）转换为本地机器码，这会拖慢应用的运行效率。

而在ART 环境中，应用在第一次安装的时候，会使用设备上的dex2oat工具进行字节码转码，把字节码预先编译成本地机器码，使其成为真正的本地应用。这个过程叫做预编译（Ahead-Of-Time，AOT）。

* 总结

Dalvik 其实可以理解为一个专为移动设备优化过的 JVM，它的大部分地方都遵守了 JVM 规范，其实那些不符合规范的地方，就可以理解为为移动设备做的优化工作。而 ART 是一个具有更高性能的 Android 虚拟机，从一开始他就是为取代 Dalvik 而来，它的 AOT 机制相比Dalvik 的 JIT 机制使得应用有更快的启动速度。同时 ART 虚拟机在垃圾回收方面也比 Dalvik 更加高性能。

简言 Dalvik -- JIT 即使编译
    ART   -- AOT 预编译 （性能更高、流畅） 



### 12.对动态加载（OSGI）的了解？ 

比较少问吧 动态加载 热修复来回答吧

### 13.常见编码方式有哪些？

ASCII、Unicode、GBK、GBK2312、UTF-8

基础的ASCII字符集是单字节字符集，用一个7位二进制数表示128个字符；

UTF8是Unicode字符集的一种编码方式，以便于适合在网络上传输和电脑存储；

### 14.utf-8 编码中的中文占几个字节？int 型占几个字节？
中文占4个字节  ； 一个utf8数字占1个字节